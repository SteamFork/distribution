From 2f9f784f587637c686e7f1919ebec2daf780f65b Mon Sep 17 00:00:00 2001
From: "Luke D. Jones" <luke@ljones.dev>
Date: Sun, 1 Sep 2024 14:30:37 +1200
Subject: [PATCH 71/79] platform/x86: asus-wmi: Refactor Ally CSEE quirks

Adjust the CSEE quirk call ordering and time delay. This fixes issues
where the MCU isn't provided enough time to complete USB device
disconnection or reconnection, particularly in powersave mode.

Introduces the asus_wmi_get_devstate_dsts() function to enable calling
DSTS without explicitly requiring access to the driver object,
required for the acpi_s2idle_dev_ops use.

Signed-off-by: Luke D. Jones <luke@ljones.dev>
---
 drivers/platform/x86/asus-wmi.c            | 181 +++++++++++++++------
 drivers/platform/x86/asus-wmi.h            |  21 +++
 include/linux/platform_data/x86/asus-wmi.h |  15 --
 3 files changed, 152 insertions(+), 65 deletions(-)

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 0c80c6b0399b..59db8f94beb6 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -143,29 +143,16 @@ module_param(fnlock_default, bool, 0444);
 #define ASUS_MINI_LED_2024_STRONG	0x01
 #define ASUS_MINI_LED_2024_OFF		0x02
 
-/* Controls the power state of the USB0 hub on ROG Ally which input is on */
 #define ASUS_USB0_PWR_EC0_CSEE "\\_SB.PCI0.SBRG.EC0.CSEE"
-/* 300ms so far seems to produce a reliable result on AC and battery */
-#define ASUS_USB0_PWR_EC0_CSEE_WAIT 1500
+/* The period required to wait after screen off/on/s2idle.check in MS */
+#define ASUS_USB0_PWR_EC0_CSEE_WAIT	200
+#define ASUS_USB0_PWR_EC0_CSEE_ON	0xB8
+#define ASUS_USB0_PWR_EC0_CSEE_OFF	0xB7
 
 static const char * const ashs_ids[] = { "ATK4001", "ATK4002", NULL };
 
 static int throttle_thermal_policy_write(struct asus_wmi *);
 
-static const struct dmi_system_id asus_ally_mcu_quirk[] = {
-	{
-		.matches = {
-			DMI_MATCH(DMI_BOARD_NAME, "RC71L"),
-		},
-	},
-	{
-		.matches = {
-			DMI_MATCH(DMI_BOARD_NAME, "RC72L"),
-		},
-	},
-	{ },
-};
-
 static bool ashs_present(void)
 {
 	int i = 0;
@@ -275,9 +262,6 @@ struct asus_wmi {
 	u32 tablet_switch_dev_id;
 	bool tablet_switch_inverted;
 
-	/* The ROG Ally device requires the MCU USB device be disconnected before suspend */
-	bool ally_mcu_usb_switch;
-
 	enum fan_type fan_type;
 	enum fan_type gpu_fan_type;
 	enum fan_type mid_fan_type;
@@ -336,6 +320,8 @@ struct asus_wmi {
 	struct asus_wmi_driver *driver;
 };
 
+static bool ally_mcu_usb_switch;
+
 /* WMI ************************************************************************/
 
 static int asus_wmi_evaluate_method3(u32 method_id,
@@ -550,6 +536,23 @@ static int asus_wmi_get_devstate(struct asus_wmi *asus, u32 dev_id, u32 *retval)
 	return 0;
 }
 
+/* For use with devices where the ACPI get method is always ASUS_WMI_METHODID_DSTS */
+static int asus_wmi_get_devstate_dsts(u32 dev_id, u32 *retval)
+{
+	int err;
+
+	err = asus_wmi_evaluate_method(ASUS_WMI_METHODID_DSTS, dev_id, 0, retval);
+	*retval &= ~ASUS_WMI_DSTS_PRESENCE_BIT;
+
+	if (err)
+		return err;
+	/* Be explicit about retval */
+	if (*retval == ASUS_WMI_UNSUPPORTED_METHOD)
+		return -ENODEV;
+
+	return 0;
+}
+
 static int asus_wmi_set_devstate(u32 dev_id, u32 ctrl_param,
 				 u32 *retval)
 {
@@ -4457,6 +4460,20 @@ static struct attribute *platform_attributes[] = {
 	NULL
 };
 
+bool asus_ally_has_quirk(unsigned long quirk)
+{
+	const struct dmi_system_id *dmi_id;
+	unsigned long quirks;
+
+	dmi_id = dmi_first_match(asus_ally_mcu_quirk);
+	if (!dmi_id)
+		return false;
+
+	quirks = (unsigned long)dmi_id->driver_data;
+	return quirks & quirk;
+}
+EXPORT_SYMBOL_GPL(asus_ally_has_quirk);
+
 static umode_t asus_sysfs_is_visible(struct kobject *kobj,
 				    struct attribute *attr, int idx)
 {
@@ -4514,6 +4531,11 @@ static umode_t asus_sysfs_is_visible(struct kobject *kobj,
 	else if (attr == &dev_attr_available_mini_led_mode.attr)
 		ok = asus->mini_led_dev_id != 0;
 
+	/* Show only for Ally X +, as Ally 1 needs it forced off */
+	if (attr == &dev_attr_mcu_powersave.attr &&
+			asus_ally_has_quirk(ASUS_ROG_ALLY_NO_POWERSAVE))
+		return 0;
+
 	if (devid != -1) {
 		ok = !(asus_wmi_get_devstate_simple(asus, devid) < 0);
 		pr_debug("%s called 0x%08x, ok: %x\n", __func__, devid, ok);
@@ -4752,6 +4774,23 @@ static int asus_wmi_add(struct platform_device *pdev)
 	if (err)
 		goto fail_platform;
 
+	ally_mcu_usb_switch = acpi_has_method(NULL, ASUS_USB0_PWR_EC0_CSEE)
+				&& dmi_check_system(asus_ally_mcu_quirk);
+	if (ally_mcu_usb_switch) {
+		/*
+		 * These steps ensure the device is in a valid good state, this is
+		 * especially important for the Ally 1 after a reboot.
+		 */
+		acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE, ASUS_USB0_PWR_EC0_CSEE_ON);
+		msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
+		platform_suspend_screen_on();
+	}
+	if (asus_ally_has_quirk(ASUS_ROG_ALLY_NO_POWERSAVE)) {
+		err = asus_wmi_set_devstate(ASUS_WMI_DEVID_MCU_POWERSAVE, 0, &result);
+		if (err)
+			pr_warn("Failed to force MCU powersave off for RC71L: %d\n", err);
+	}
+
 	/* ensure defaults for tunables */
 	asus->ppt_pl2_sppt = 5;
 	asus->ppt_pl1_spl = 5;
@@ -4764,7 +4803,7 @@ static int asus_wmi_add(struct platform_device *pdev)
 	asus->egpu_enable_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_EGPU);
 	asus->dgpu_disable_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_DGPU);
 	asus->kbd_rgb_state_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_TUF_RGB_STATE);
-	asus->ally_mcu_usb_switch = acpi_has_method(NULL, ASUS_USB0_PWR_EC0_CSEE)
+	ally_mcu_usb_switch = acpi_has_method(NULL, ASUS_USB0_PWR_EC0_CSEE)
 						&& dmi_check_system(asus_ally_mcu_quirk);
 
 	if (asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_MINI_LED_MODE))
@@ -4956,34 +4995,6 @@ static int asus_hotk_resume(struct device *device)
 	return 0;
 }
 
-static int asus_hotk_resume_early(struct device *device)
-{
-	struct asus_wmi *asus = dev_get_drvdata(device);
-
-	if (asus->ally_mcu_usb_switch) {
-		/* sleep required to prevent USB0 being yanked then reappearing rapidly */
-		if (ACPI_FAILURE(acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE, 0xB8)))
-			dev_err(device, "ROG Ally MCU failed to connect USB dev\n");
-		else
-			msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
-	}
-	return 0;
-}
-
-static int asus_hotk_prepare(struct device *device)
-{
-	struct asus_wmi *asus = dev_get_drvdata(device);
-
-	if (asus->ally_mcu_usb_switch) {
-		/* sleep required to ensure USB0 is disabled before sleep continues */
-		if (ACPI_FAILURE(acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE, 0xB7)))
-			dev_err(device, "ROG Ally MCU failed to disconnect USB dev\n");
-		else
-			msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
-	}
-	return 0;
-}
-
 static int asus_hotk_restore(struct device *device)
 {
 	struct asus_wmi *asus = dev_get_drvdata(device);
@@ -5024,11 +5035,76 @@ static int asus_hotk_restore(struct device *device)
 	return 0;
 }
 
+static bool asus_ally_check_powersave(void)
+{
+	u32 powersave = 0;
+	int err;
+
+	/* Ally X requires this if powersave is enabled */
+	if (!asus_ally_has_quirk(ASUS_ROG_ALLY_NO_POWERSAVE)) {
+		err = asus_wmi_get_devstate_dsts(ASUS_WMI_DEVID_MCU_POWERSAVE, &powersave);
+		if (err)
+			pr_err("Failed to read mcu_powersave. %d\n", err);
+		return powersave == 1;
+	}
+
+	return false;
+}
+
+static void asus_ally_s2idle_restore(void)
+{
+	if (ally_mcu_usb_switch) {
+		/* The Ally X requires this if in powersave mode or devices fail to init */
+		if (asus_ally_check_powersave())
+			if (ACPI_FAILURE(acpi_execute_simple_method(NULL,
+					ASUS_USB0_PWR_EC0_CSEE, ASUS_USB0_PWR_EC0_CSEE_ON)))
+				pr_err("ROG Ally MCU failed to restore\n");
+
+		platform_suspend_screen_on();
+		msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
+	}
+}
+
+static int asus_hotk_prepare(struct device *device)
+{
+	if (ally_mcu_usb_switch) {
+		/* The Ally X requires this if in powersave mode or devices fail to init */
+		if (asus_ally_check_powersave())
+			if (ACPI_FAILURE(acpi_execute_simple_method(NULL,
+					ASUS_USB0_PWR_EC0_CSEE,	ASUS_USB0_PWR_EC0_CSEE_OFF)))
+				pr_err("ROG Ally MCU failed to suspend\n");
+
+		platform_suspend_screen_off();
+		/*
+		 * Time here greatly impacts the wake behaviour
+		 * Too little and device never appears, too much and disconnect events occur
+		 */
+		msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
+	}
+	return 0;
+}
+
+/*
+ * Ally X requires waking on AC-change if powersave is enabled.
+ * To prevent confusion of different behaviour, apply for all Ally
+ * regardless of quirks.
+ */
+static bool asus_ally_enable_wake(void)
+{
+	return dmi_first_match(asus_ally_mcu_quirk) != NULL;
+}
+
+/* Use only for Ally devices due to the wake_on_ac */
+static struct acpi_s2idle_dev_ops asus_ally_s2idle_dev_ops = {
+	.restore = asus_ally_s2idle_restore,
+	/* Requirement for at least Ally X to prevent powersave issues */
+	.enable_wake_on_ac_plug = asus_ally_enable_wake,
+};
+
 static const struct dev_pm_ops asus_pm_ops = {
 	.thaw = asus_hotk_thaw,
 	.restore = asus_hotk_restore,
 	.resume = asus_hotk_resume,
-	.resume_early = asus_hotk_resume_early,
 	.prepare = asus_hotk_prepare,
 };
 
@@ -5056,6 +5132,10 @@ static int asus_wmi_probe(struct platform_device *pdev)
 			return ret;
 	}
 
+	ret = acpi_register_lps0_dev(&asus_ally_s2idle_dev_ops);
+	if (ret)
+		pr_warn("failed to register LPS0 sleep handler in asus-wmi\n");
+
 	return asus_wmi_add(pdev);
 }
 
@@ -5088,6 +5168,7 @@ EXPORT_SYMBOL_GPL(asus_wmi_register_driver);
 
 void asus_wmi_unregister_driver(struct asus_wmi_driver *driver)
 {
+	acpi_unregister_lps0_dev(&asus_ally_s2idle_dev_ops);
 	platform_device_unregister(driver->platform_device);
 	platform_driver_unregister(&driver->platform_driver);
 	used = false;
diff --git a/drivers/platform/x86/asus-wmi.h b/drivers/platform/x86/asus-wmi.h
index d02f15fd3482..631464d18008 100644
--- a/drivers/platform/x86/asus-wmi.h
+++ b/drivers/platform/x86/asus-wmi.h
@@ -16,6 +16,7 @@
 
 #include <linux/platform_device.h>
 #include <linux/i8042.h>
+#include <linux/dmi.h>
 
 #define ASUS_WMI_KEY_IGNORE (-1)
 #define ASUS_WMI_BRN_DOWN	0x2e
@@ -86,4 +87,24 @@ struct asus_wmi_driver {
 int asus_wmi_register_driver(struct asus_wmi_driver *driver);
 void asus_wmi_unregister_driver(struct asus_wmi_driver *driver);
 
+#define ASUS_ROG_ALLY_NO_POWERSAVE	BIT(0)
+
+/* To be used by both asus-armoury and asus-wmi */
+static const struct dmi_system_id asus_ally_mcu_quirk[] = {
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_NAME, "RC71L"),
+		},
+		.driver_data = (void *)(ASUS_ROG_ALLY_NO_POWERSAVE),
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_NAME, "RC72L"),
+		},
+	},
+	{ },
+};
+
+bool asus_ally_has_quirk(unsigned long quirk);
+
 #endif /* !_ASUS_WMI_H_ */
diff --git a/include/linux/platform_data/x86/asus-wmi.h b/include/linux/platform_data/x86/asus-wmi.h
index 7decbe2c2ad7..b601b245a035 100644
--- a/include/linux/platform_data/x86/asus-wmi.h
+++ b/include/linux/platform_data/x86/asus-wmi.h
@@ -201,19 +201,4 @@ static const struct dmi_system_id asus_use_hid_led_dmi_ids[] = {
 	{ },
 };
 
-/* To be used by both hid-asus and asus-wmi to determine which controls kbd_brightness */
-static const struct dmi_system_id asus_ally_mcu_quirk[] = {
-	{
-		.matches = {
-			DMI_MATCH(DMI_BOARD_NAME, "RC71L"),
-		},
-	},
-	{
-		.matches = {
-			DMI_MATCH(DMI_BOARD_NAME, "RC72L"),
-		},
-	},
-	{ },
-};
-
 #endif	/* __PLATFORM_DATA_X86_ASUS_WMI_H */
-- 
2.43.2

